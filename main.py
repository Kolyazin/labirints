# This is a sample Python script.
from random import random, randint


# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.

# Итак, нам нужна программа, которая
# 1. получит схему лабиринта в виде последовательности из семи строк
#   по семь символов в строке. Каждая входная строка представляет горизонталь лабиринта, а порядок строк соответствует
#   порядку горизонталей, считая сверху вниз. Элементы лабиринта (символы в строке) упорядочены слева направо.
#   "Пустой" элемент лабиринта (доступный для прохода) во входной строке обозначается точкой ("."),
#   а символ звездочка ("*") соответствует элементу со стеной (закрытому для прохода).
# 2. попробует найти кратчайший путь от крайнего верхнего левого узла до крайнего нижнего правого узла соблюдая
#   следующие условия: путь должен проходить только через "свободные" узлы и не может включать в себя один и тот же
#   узел более одного раза. "Соседними" узлами в пути могут быть узлы, смежные по вертикали или по горизонтали,
#   но не по диагонали.
# 3. выведет графическое представление пути, если путь найден. В противном случае выведет сообщение об отсутствии пути.
# 4. выведет схему лабиринта
#
#
#

# Получает с консоли семь строк содержащих по семь символов * или .
# если get_from_console = true, то ждем ввода лабиринта пользователем, если нет, то отдаем заданный по умолчанию.
def get_labyrinth(get_from_console: bool) -> []:
    # инициализирую массив из семи строк, точнее список, т.к. в питоне нет массивов
    s = ['..**..*',
         '..*..**',
         '.**.***',
         '....***',
         '**....*',
         '*..**.*',
         '*..**..']
    # если get_from_console не true, то возвращаю заданный по умолчанию лабиринт
    if not get_from_console:
        return s
    # вывожу подсказку
    print('Определите схему лабиринта (7 строк по 7 символов "•" или "*"):')
    # цикл от 0 до 6 включительно (как раз 7 раз сработает)
    for i in range(7):
        # бесконечный цикл выход из которого будет только тогда, когда пользователь введет корректную строку,
        # длиной в 7 символов и только точки или звездочки
        while True:
            # жду ввода пользователя
            s[i] = input('Строка %d:' % i)
            # проверяю, что строка длиной в 7 символов и только точки или звездочки
            # и если это так, то прерываю цикл while и перехожу к следующему значению for
            if (len(s[i]) == 7) and (s[i].count('.') + s[i].count('*') == 7):
                break
            # если дощли до сюда, значит предыдущее условие не сработало, значит в введенная строка не такая как надо
            # ругаюсь и откправляю вводить еще раз, цикл while не прерывается, i не меняется.
            print('Некорректный ввод, попробуйте еще раз.')
    # возвращаю полученный лабиринт
    return s


# так как для поска пути используются веса клеток, то преобразую исходный лабиринт состоящий из . и * в
# набор весов, где -1 это стенка, 0 это свободный узел, 1 начало пути.
def get_weights(str_lab: []) -> [[]]:
    # инициализирую двумерный массис, а точнее, для питона, список списков
    # row строк
    # elem элементов в каждой строке
    # row и elem вычисляются из входного массива
    row = len(str_lab)
    elem = len(str_lab[0])
    # можно так:
    # w = [0] * row
    # for i in range(row):
    #     w[i] = [0] * elem
    # а можно так:
    # w = []
    # for i in range(row):
    #     w.append([0] * elem)
    # а можно так:
    w = [[0] * elem for i in range(row)]
    # присваиваю веса
    # цикл по строкам
    for i in range(row):
        # цикл по элементам
        for j in range(elem):
            # можно так:
            # if str_lab[i][j] == '*':
            #     w[i][j] = -1
            # else:
            #     w[i][j] = 0
            # а можно так
            w[i][j] = -1 if str_lab[i][j] == '*' else 0
    # возвращаю веса
    return w


#
def colorize(w: [[]], start_point: (int, int)) -> [[]]:
    # вычисляю количество строк в исходном массиве с весами
    row = len(w)
    # вычисляю количество элементов в строке в исходном массиве с весами
    elem = len(w[0])
    # создаю новый двумерный массив с которым и буду работать и его возвращать,
    # это сделано для того, чтобы не портить исходный массив, т.к. он передается в функцию по ссылке
    c = [[0] * elem for i in range(row)]
    # так как функции копирования двумерных массивов в питон не встроено, а разбираться с функцией deepcopy
    # из пакета copy неохота, то тупо копирую поэлементно один массив в другой
    for i in range(row):
        for j in range(elem):
            c[i][j] = w[i][j]
    # делаю буфер fifo (первый пришел, первый ушел) на основе массива
    # в который будут складываться координаты соседних узлов, которые доступны из текущего узла и не являются стенкой
    # и которым будет присваиваться вес на единицу больше чем у текущего узла
    fifo = []
    # кладу координаты начального узла в буфер
    fifo.append(start_point)
    # координаты точки старта
    row, elem = start_point
    # вес первого узла = 1
    c[row][elem] = 1
    # цикл работает пока есть не обследованные узлы
    while len(fifo) != 0:
        # достаю узел из буфера, удаляя его оттуда
        row, elem = fifo.pop(0)
        # задаю вес соседей узла как вес самого узла + 1
        new_weight = c[row][elem] + 1
        # проверяю не вышел ли за границы массива, если бы добавил внешние стенки массиву,
        # то это условие можно было не добавлять
        if row + 1 < len(c):
            # проверяю, что нижний узел свободен для посещения и не является стенкой
            if c[row + 1][elem] == 0:
                # присваиваю ему вес
                c[row + 1][elem] = new_weight
                # и кладу его координаты в буфер, чтобы в дальнейшем обойти его соседей
                fifo.append((row + 1, elem))
        # проверяю не вышел ли за границы массива
        if row - 1 >= 0:
            # проверяю, что верхний узел свободен для посещения и не является стенкой
            if c[row - 1][elem] == 0:
                # присваиваю ему вес
                c[row - 1][elem] = new_weight
                # и кладу его координаты в буфер, чтобы в дальнейшем обойти его соседей
                fifo.append((row - 1, elem))
        # проверяю не вышел ли за границы массива
        if elem + 1 < len(c[row]):
            # проверяю, что правый узел свободен для посещения и не является стенкой
            if c[row][elem + 1] == 0:
                # присваиваю ему вес
                c[row][elem + 1] = new_weight
                # и кладу его координаты в буфер, чтобы в дальнейшем обойти его соседей
                fifo.append((row, elem + 1))
        # проверяю не вышел ли за границы массива
        if elem - 1 >= 0:
            # проверяю, что левый узел свободен для посещения и не является стенкой
            if c[row][elem - 1] == 0:
                # присваиваю ему вес
                c[row][elem - 1] = new_weight
                # и кладу его координаты в буфер, чтобы в дальнейшем обойти его соседей
                fifo.append((row, elem - 1))
    return c


# поиск пути в лабиринте, лабиринт в виде двумерного массива с весами
def find_path(w: [[]], end_point: (int, int)) -> []:
    # получаю координаты конечного узла
    row, elem = end_point
    # если конечный узел это стена или вес его равен 0, значит до него невозможно добраться из стартового узла
    if w[row][elem] == 0 or w[row][elem] == -1:
        # возвращаю пустой список как признак отсутствия пути
        return []
    # если путь есть, то количество шагов равно весу конечного узла, такого размера и формирую массив
    p = [(0, 0)] * w[row][elem]
    # работаю пока не достигну узла с весом 1 - это стартовый узел
    while w[row][elem] != 1:
        # ищу соседа с весом меньше на 1
        neighbour_weight = w[row][elem] - 1
        # добавляю в путь координаты очередного найденного узла, в самом начале это координаты конечного узла
        p[neighbour_weight] = (row, elem)
        # проверяю не вышел ли за границы массива
        if row + 1 < len(w):
            # проверяю вес соседа
            if w[row + 1][elem] == neighbour_weight:
                # если нашел такого соседа, то делаю его координаты текущими
                row = row + 1
                # прекращаю выполнение текущей итерации и перехожу к новой, чтобы не выполнялись условия ниже
                continue
        # проверяю не вышел ли за границы массива
        if row - 1 >= 0:
            # проверяю вес соседа
            if w[row - 1][elem] == neighbour_weight:
                # если нашел такого соседа, то делаю его координаты текущими
                row = row - 1
                # прекращаю выполнение текущей итерации и перехожу к новой, чтобы не выполнялись условия ниже
                continue
        # проверяю не вышел ли за границы массива
        if elem + 1 < len(w[row]):
            # проверяю вес соседа
            if w[row][elem + 1] == neighbour_weight:
                # если нашел такого соседа, то делаю его координаты текущими
                elem = elem + 1
                # прекращаю выполнение текущей итерации и перехожу к новой, чтобы не выполнялись условия ниже
                continue
        # проверяю не вышел ли за границы массива
        if elem - 1 >= 0:
            # проверяю вес соседа
            if w[row][elem - 1] == neighbour_weight:
                # если нашел такого соседа, то делаю его координаты текущими
                elem = elem - 1
                # прекращаю выполнение текущей итерации и перехожу к новой, чтобы не выполнялись условия ниже
                continue
    # заодно добавляю координаты узла старта в начало массива
    p[0] = (row, elem)
    # возвращаю путь
    return p


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    # получаю в переменную лабиринт, заранее заданный (False) или с клавиатуры (True)
    src_lab = get_labyrinth(False)
    # вывожу его на экран построчно
    for row in src_lab:
        print(row)
    print('\n')

    # задаю стартовый узел
    start_point = (0, 0)
    # задаю конечный узел, т.к. отсчет начинается с 0, то 7й элемент будет иметь порядковый номер 6
    end_point = (6, 6)
    # создаю массив с весами элементов, где вместо . и * стоят -1 для стенки и 0 для пустого места
    weights = get_weights(src_lab)
    # проставляю веса узлов начиная от стартового
    weights = colorize(weights, start_point)
    # получаю путь до него или пустой массив, если путь не найден
    path = find_path(weights, end_point)

    if len(path) == 0:
        print('Путь не найден!')
    else:
        # прохожу по всем точкам пути
        for i in range(len(path)):
            # беру координаты
            row, elem = path[i]
            # можно так, но будет без буквы ё
            # по ним вставляю букву, беру код буквы а и прибавляю порядковый номер точки пути и
            # преобразую обратно в букву, а+1 будет б, +2 будет в и т.д.
            # i % 32 это я беру остаток от деления на 32, чтобы когда количество точек пути превысит количество
            # букв алфавита, то снова началось с начала алфавита, т.е. когда будет 34,35,36, то остаток
            # от деления будет 1,2,3 и к а будет прибавляться 1,2,3 и будет опять получаться б,в,г
            # а 32, а не 33 потому что буква ё в другом месте находится, не по порядку
            # src_lab[row] = src_lab[row][:elem] + chr(ord('а') + i % 32) + src_lab[row][elem + 1:]
            # а можно так, можно задать любой алфавит
            alphabet = ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р',
                        'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ь', 'ы', 'ъ', 'э', 'ю', 'я']
            src_lab[row] = src_lab[row][:elem] + alphabet[i % 33] + src_lab[row][elem + 1:]
        # вывожу на экран полученный лабиринт
        for row in src_lab:
            print(row)
        print('\n')
